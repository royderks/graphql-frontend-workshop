## Getting started

Clone this repository (or fork it), move into the directory `introduction` install all dependencies by running:

```bash
npm i
# or
yarn
```

After the installation is completed, run the development server:

```bash
npm start
# or
yarn start
```

Open http://localhost:3000 in your browser to see the result. Data from DEV.to is being pulled into the application.

## What's next?

To get a free GraphQL API, you need to install the [StepZen](https://stepzen.com) CLI:

```bash
npm i -g stepzen
```

The CLI is installed globally, so you can use it in different projects too.

After the installation is completed, you can [signup](https://stepzen.com/signup) for a free account. You will be able to use this account to create a secure GraphQL API for your data. Also, you can proceed without signing up and use a public GraphQL API endpoint.

## And Finally...

[Install Apollo Client DevTools](https://www.apollographql.com/docs/react/development-testing/developer-tooling#apollo-client-devtools) in your browser to inspect the GraphQL queries and mutations that are being executed in the application.

## Excercises

### Excercise 1

This application uses a GraphQL API created with StepZen, that is connected to DEV.to. To deploy this GraphQL API you need to use the StepZen CLI. You can then use GraphQL to explore the API.

To deploy the API, run the following command:

```bash
cd stepzen
stepzen start
```

You can continue with a public endpoint or [signup](https://stepzen.com/signup) for a free StepZen account to get a private, secure endpoint.

The GraphQL API has queries and mutations to retrieve articles, and "upvote" an article. You can explore the API by using the GraphiQL interface. The GraphiQL interface is available at the endpoint printed in the terminal where you ran `stepzen start`, this endpoint starts with `http://` (the `localhost` endpoint is only available for local epxloration with GraphiQL).

Run a query to upvote an article, and then run a query to retrieve the article again. What is the difference in the `upvotes` field for the article?

<details>
<summary>Show solution</summary>
<p>

```graphql
query GetArticleById($id: String!) {
  article(id: $id) {
    id
    title
    description
    upvotes
  }
}

# then

mutation UpvoteArticle($postId: Int!) {
  upvoteArticle(postId: $postId) {
    id
  }
}

# compare

query GetArticleById($id: String!) {
  article(id: $id) {
    id
    title
    description
    upvotes
  }
}
```

</p>
</details>

### Excercise 2

Authentication is important for every API. When you use StepZen with a public endpoint, you don't have to deal with authentication. But when you do do sign up for a free account, you will get a secure and private endpoint. This endpoint needs an API key passed in the `Authorization` header.

But there is also a "second layer" of authentication, meaning the users that need to authenticate with the API. This is done by using a JWT token. The JWT token is generated by the StepZen API, and can be used to authenticate users. The JWT token is passed in the `Authorization` header, and is prefixed with `Bearer `.

To get a JWT token, you need to run the following mutation:

```graphql
mutation LoginUser(
  $email: String = "demo@stepzen.com"
  $password: String = "demo"
) {
  login(email: $email, password: $password) {
    id
    email
    token
  }
}
```

Let's dive into the React application.

Hook up the component `src/components/Login.js` to work with this mutation. Store the returned `token` in localStorage.

> Bonus: Add a logout button to the `src/App.js` component. When the user clicks the button, the token should be removed from localStorage.

<details>
<summary>Show solution</summary>
<p>

[Look at the code](https://github.com/royderks/graphql-frontend-workshop/tree/advanced/ex-2)

</p>
</details>

### Excercise 3

GraphQL has built-in directives, which can be used to include (`@include`) or skip (`@skip`) fields in a query. You can use these directives to create a query that only returns the `id` and `title` of an article when a variable is passed to the query.

Can you alter the query to get the `upvotes` for the articles on the homepage so it will only return the upvotes when a variable is passed to the query that indicated the user is logged in? Also, hide the upvote button on the homepage if the query didn't return the `upvotes` field.

<details>
<summary>Show solution</summary>
<p>

[Look at the code](https://github.com/royderks/graphql-frontend-workshop/tree/advanced/ex-3)

</p>
</details>

### Excercise 4

When you are resuing parts of fields, you can use fragments to avoid repeating yourself. Fragments can be used to define a part of a query, and then you can use the fragment in multiple queries.

The fields for an article in `src/operations.js` are repeated in the `GetArticles` query and the `GetArticleById` query. Can you create a fragment for the fields of an article, and use the fragment in both queries?

<details> 
<summary>Show solution</summary>
<p>

[Look at the code](https://github.com/royderks/graphql-frontend-workshop/tree/advanced/ex-4)

</p>
</details>

### Excercise 5

Using TypeScript together with GraphQL is a great combination. You can use TypeScript to define the types for your GraphQL schema, and you can use TypeScript to define the types for your GraphQL queries and mutations.

To get started with TypeScript, you need to install the TypeScript compiler:

```bash
npm install --save-dev typescript @types/node @types/react @types/react-dom @types/jest @types/react-router-dom @types/react-modal

# or

yarn add -D typescript @types/node @types/react @types/react-dom @types/jest @types/react-router-dom @types/react-modal
```

Next, rename any file to be a TypeScript file (e.g. `src/index.js` to `src/index.tsx`) and restart your development server!

<details>
<summary>Show solution</summary>
<p>

[Look at the code](https://github.com/royderks/graphql-frontend-workshop/tree/advanced/ex-5)

</p>
</details>

### Excercise 6

You can use the GraphQL schema to autogenerate the TypeScript types instead of having to manually type these. To do this, you need to install the `graphql-codegen` CLI, which you first need to install using npm (including its dependencies):

```bash
npm i --save-dev @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-operations
# or
yarn add -D @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-operations
```

Create a new file called `codegen.yml` with the following contents:

```yaml
overwrite: true
schema: 'https://YOUR_USERNAME.stepzen.net/api/newsapp/__graphql'
documents: 'src/operations.ts'
generates:
  ./src/generated/types.ts:
    plugins:
      - 'typescript'
      - 'typescript-operations'
```

Run `npx graphql-codegen --config codegen.yml` to generate the TypeScript files based on the GraphQL schema. Instead of using `npx` you can also create a new script in `package.json` to generate the types.

Delete the file `src/types.ts` and replace all the missing type definitions with the generated types. Are there any other changes you need to make to our code?

<details>
<summary>Show solution</summary>
<p>

[Look at the code](https://github.com/royderks/graphql-frontend-workshop/tree/advanced/ex-6)

</p>
</details>

### Excercise 7

Next to the types for the GraphQL schema, you can also autogenerate type-safe Apollo Client Hooks for your queries and mutations. To do this, you need to install a new plugin for the the `graphql-codegen` CLI:

```bash
npm i --save-dev @graphql-codegen/typescript-react-apollo

#or

yarn add -D @graphql-codegen/typescript-react-apollo
```

And add this plugin to the `codegen.yml` file for the code generator.

Run the script to generate the TypeScript types again. This time it will also create type-safe Hooks for all the operations defined in `src/operations.ts`. Replace all the Apollo Client Hooks with the generated ones.

<details>
<summary>Show solution</summary>
<p>

[Look at the code](https://github.com/royderks/graphql-frontend-workshop/tree/advanced/ex-7)

</p>
</details>

## Excercise 8

Now that we have a working application, we can start adding tests. For this we'll be using React Testing Library and Jest. Apollo Client also comes with a set of built-in utilities to help you write tests for your application, such as giving you a `MockedProvider` that you can use to pass mocks to the Apollo Client Hooks in your components.

Add the testing library for React:

```bash
npm install --save-dev @testing-library/react @testing-library/jest-dom

# or

yarn add -D @testing-library/react @testing-library/jest-dom
```

And make sure the testing script in `package.json` is correct:

```json
{
  "scripts": {
    // ...
    "test": "react-scripts test"
  }
}
```

Now you can run `npm run test` or `yarn test` to run the tests. Let's start by adding a test for the `Article` component. Create a new file called `Article.test.jsx` (or `.tsx`) in the `src` folder and add the following test:

```jsx
import '@testing-library/jest-dom';
import { render, screen } from '@testing-library/react';
import { MockedProvider } from '@apollo/client/testing';
import Articles from './Article';

const mocks = []; // We'll fill this in next

it('renders without error', async () => {
  render(
    <MockedProvider mocks={mocks} addTypename={false}>
      <Articles />
    </MockedProvider>,
  );
  expect(await screen.findByText('Loading...')).toBeInTheDocument();
});
```

Or choose a different file structure to add the test file, depending on your own preference.

<details>
<summary>Show solution</summary>
<p>

[Look at the code](https://github.com/royderks/graphql-frontend-workshop/tree/advanced/ex-8)

</p>
</details>

## Excercise 9

Let's add some mock data and really test our GraphQL application. We'll be using `mocks` option on `MockedProvider` from Apollo Client to mock the data that we get from the GraphQL API. The `MockedProvider` is a component that you can wrap around your component to pass mock data to the Apollo Client Hooks. It will only return the mock data when the query or mutation **exactly** matches the one that you passed to the `mocks` option.

Test the `Article` component using mock data, check for the existince of the `title` and `description` fields in the rendered component.

> Hint: Check the contents of `src/components/Article`, are there any libraries you should mock?

<details>
<summary>Show solution</summary>
<p>

[Look at the code](https://github.com/royderks/graphql-frontend-workshop/tree/advanced/ex-9)

</p>
</details>

## BONUS: Test all components

Next to the `Article` component, you could also test the other components in the application. Try to write tests for the `Home` and `Login` components. Use the `Article` component as an example.

## BONUS: Change the client to use `urql`

There are more client-side libraries available to use GraphQL in your frontend application. After Apollo Client, [urql](https://formidable.com/open-source/urql/docs/basics/react-preact/) is the second most popular one.

Why use urql instead of Apollo Client? Some reasons might be:

- Smaller bundle size (+/-5kb vs +/-32kb)
- Easier to customize and extend (using Exchanges)
- Lots of plugins for common use cases (like auth & pagination)

> There's also [Relay](https://relay.dev), but the way Relay handles data coming from GraphQL is very different from Apollo Client and urql. Relay is more of a framework than a library, and it's not as easy to get started with. Relay is also not as popular as Apollo Client and urql, so we won't be using it in this workshop.

See [here](https://formidable.com/open-source/urql/docs/comparison/) for a complete comparison between Apollo Client, urql and Relay.

Convert the application to use urql instead of Apollo Client. This means you would need to change the `client` in `src/index.tsx`, and there are some slight differences between the returned data from the different Hooks. You cana install urql from npm:

```bash
npm i urql

#or

yarn add urql
```

> Hint: You can autogenerate the Hooks for urql in the same way as for Apollo Client. Make sure to install `@graphql-codegen/typescript-urql` and add it to the list of plugins for the code generator.

## BONUS: Use cursor-based pagination

GraphQL APIs typically use "cursor-based" pagination. This means that you can use a cursor to get the next page of results. The cursor is a string that is returned with the results, and can be used to get the next page of results.

Cursor-based pagination is for example used by [Relay](https://relay.dev/graphql/connections.htm), and is also supported by the StepZen GraphQL API. The query parameters for `first` and `after` are used for pagination. With `first` you define the amount of results, while `after` is the cursor of the last result on the previous page. Think of `cursor` as `offset`, which you might know from other pagination methods. To dynamically get the value for `after` you should use the value from the `endCursor` field in `pageInfo`. Also, `hasNextPage` lets you know if there is a next page based on `first` and `endCursor` values.

The results won't be the response type we've seen before but a "connection" type:

- Connection type: a connection is a collection of objects with metadata such as:
  - `pageInfo` has all the information about the current page and contains `hasNextPage`, `hasPreviousPage`, `startCursor`, `endCursor`.
  - `edges` will provide you flexibility to use your data (node). Each edge has:
    - a `node`: a record or a data
    - a `cursor`: base64 encoded string to help GraphQL with pagination

Apply cursor-based pagination for the articles listed on the homepage. Make sure the count on the left side is working correctly, meaning the results will be appended to the previously loaded results.

> Hint: have a look at the `paginatedArticles` query in the GraphQL API schema.

